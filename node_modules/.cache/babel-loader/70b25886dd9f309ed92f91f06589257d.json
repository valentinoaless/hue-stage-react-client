{"ast":null,"code":"var ip = require('ip');\n\nvar os = require('os');\n\nvar net = require('net');\n\nvar cp = require('mz/child_process');\n\nvar getIPRange = require('get-ip-range');\n\nvar parseLinux = require('./parser/linux');\n\nvar parseWin32 = require('./parser/win32');\n\nvar parseRow = require('./parser');\n\nvar servers;\nvar lock = {};\nconst TEN_MEGA_BYTE = 1024 * 1024 * 10;\nconst ONE_MINUTE = 60 * 1000;\nconst options = {\n  maxBuffer: TEN_MEGA_BYTE,\n  timeout: ONE_MINUTE\n};\n/**\n * Finds all local devices (ip and mac address) connectd to the current network.\n */\n\nmodule.exports = function findLocalDevices(address) {\n  var key = String(address);\n\n  if (isRange(address)) {\n    try {\n      servers = getIPRange(key);\n    } catch (error) {\n      // Note: currently doesn't throw the intended error message from the package maintainer\n      // It will still be caught, PR here though: https://github.com/JoeScho/get-ip-range/pull/6\n      return error;\n    }\n  } else {\n    servers = getServers();\n  }\n\n  if (!lock[key]) {\n    if (!address || isRange(key)) {\n      lock[key] = pingServers().then(arpAll).then(unlock(key));\n    } else {\n      lock[key] = pingServer(address).then(arpOne).then(unlock(key));\n    }\n  }\n\n  return lock[key];\n};\n\nfunction isRange(address) {\n  return address && new RegExp('/|-').test(address);\n}\n/**\n * Gets the current list of possible servers in the local networks.\n */\n\n\nfunction getServers() {\n  var interfaces = os.networkInterfaces();\n  var result = [];\n\n  for (var key in interfaces) {\n    var addresses = interfaces[key];\n\n    for (var i = addresses.length; i--;) {\n      var address = addresses[i];\n\n      if (address.family === 'IPv4' && !address.internal) {\n        var subnet = ip.subnet(address.address, address.netmask);\n        var current = ip.toLong(subnet.firstAddress);\n        var last = ip.toLong(subnet.lastAddress) - 1;\n\n        while (current++ < last) result.push(ip.fromLong(current));\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Sends a ping to all servers to update the arp table.\n */\n\n\nfunction pingServers() {\n  return Promise.all(servers.map(pingServer));\n}\n/**\n * Pings and individual server to update the arp table.\n */\n\n\nfunction pingServer(address) {\n  return new Promise(function (resolve) {\n    var socket = new net.Socket();\n    socket.setTimeout(1000, close);\n    socket.connect(80, address, close);\n    socket.once('error', close);\n\n    function close() {\n      socket.destroy();\n      resolve(address);\n    }\n  });\n}\n/**\n * Reads the arp table.\n */\n\n\nfunction arpAll() {\n  return cp.exec('arp -a', options).then(parseAll);\n}\n/**\n * Parses arp scan data into a useable collection.\n */\n\n\nfunction parseAll(data) {\n  if (!data || !data[0]) {\n    return [];\n  }\n\n  if (process.platform.includes('linux')) {\n    var rows = data[0].split('\\n');\n    return rows.map(function (row) {\n      return parseLinux(row, servers);\n    }).filter(Boolean);\n  } else if (process.platform.includes('win32')) {\n    var winRows = data[0].split('\\n').splice(1);\n    return winRows.map(function (row) {\n      return parseWin32(row, servers);\n    }).filter(Boolean);\n  }\n\n  return data[0].trim().split('\\n').map(function (row) {\n    return parseRow(row, servers);\n  }).filter(Boolean);\n}\n/**\n * Reads the arp table for a single address.\n */\n\n\nfunction arpOne(address) {\n  if (!ip.isV4Format(address) && !ip.isV6Format(address)) {\n    return Promise.reject(new Error('Invalid IP address provided.'));\n  }\n\n  return cp.exec('arp -n ' + address, options).then(parseOne);\n}\n/**\n * Parses a single row of arp data.\n */\n\n\nfunction parseOne(data) {\n  if (!data || !data[0]) {\n    return;\n  }\n\n  if (process.platform.includes('linux')) {\n    // ignore unresolved hosts (can happen when parseOne returns only one unresolved host)\n    if (data[0].indexOf('no entry') >= 0) {\n      return;\n    } // remove first row (containing \"headlines\")\n\n\n    var rows = data[0].split('\\n').slice(1)[0];\n    return parseLinux(rows, servers, true);\n  } else if (process.platform.includes('win32')) {\n    return; // currently not supported\n  }\n\n  return parseRow(data[0], servers);\n}\n/**\n * Clears the current promise and unlocks (will ping servers again).\n */\n\n\nfunction unlock(key) {\n  return function (data) {\n    lock[key] = null;\n    return data;\n  };\n}","map":{"version":3,"sources":["/Users/barco/Desktop/sites/tests/dnd-tests/test6/client/node_modules/local-devices/src/index.js"],"names":["ip","require","os","net","cp","getIPRange","parseLinux","parseWin32","parseRow","servers","lock","TEN_MEGA_BYTE","ONE_MINUTE","options","maxBuffer","timeout","module","exports","findLocalDevices","address","key","String","isRange","error","getServers","pingServers","then","arpAll","unlock","pingServer","arpOne","RegExp","test","interfaces","networkInterfaces","result","addresses","i","length","family","internal","subnet","netmask","current","toLong","firstAddress","last","lastAddress","push","fromLong","Promise","all","map","resolve","socket","Socket","setTimeout","close","connect","once","destroy","exec","parseAll","data","process","platform","includes","rows","split","row","filter","Boolean","winRows","splice","trim","isV4Format","isV6Format","reject","Error","parseOne","indexOf","slice"],"mappings":"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","sourcesContent":["var ip = require('ip')\nvar os = require('os')\nvar net = require('net')\nvar cp = require('mz/child_process')\nvar getIPRange = require('get-ip-range')\n\nvar parseLinux = require('./parser/linux')\nvar parseWin32 = require('./parser/win32')\nvar parseRow = require('./parser')\n\nvar servers\nvar lock = {}\n\nconst TEN_MEGA_BYTE = 1024 * 1024 * 10\nconst ONE_MINUTE = 60 * 1000\nconst options = {\n  maxBuffer: TEN_MEGA_BYTE,\n  timeout: ONE_MINUTE\n}\n\n/**\n * Finds all local devices (ip and mac address) connectd to the current network.\n */\nmodule.exports = function findLocalDevices (address) {\n  var key = String(address)\n\n  if (isRange(address)) {\n    try {\n      servers = getIPRange(key)\n    } catch (error) {\n      // Note: currently doesn't throw the intended error message from the package maintainer\n      // It will still be caught, PR here though: https://github.com/JoeScho/get-ip-range/pull/6\n      return error\n    }\n  } else {\n    servers = getServers()\n  }\n\n  if (!lock[key]) {\n    if (!address || isRange(key)) {\n      lock[key] = pingServers().then(arpAll).then(unlock(key))\n    } else {\n      lock[key] = pingServer(address).then(arpOne).then(unlock(key))\n    }\n  }\n\n  return lock[key]\n}\n\nfunction isRange (address) {\n  return address && new RegExp('/|-').test(address)\n}\n\n/**\n * Gets the current list of possible servers in the local networks.\n */\nfunction getServers () {\n  var interfaces = os.networkInterfaces()\n  var result = []\n\n  for (var key in interfaces) {\n    var addresses = interfaces[key]\n    for (var i = addresses.length; i--;) {\n      var address = addresses[i]\n      if (address.family === 'IPv4' && !address.internal) {\n        var subnet = ip.subnet(address.address, address.netmask)\n        var current = ip.toLong(subnet.firstAddress)\n        var last = ip.toLong(subnet.lastAddress) - 1\n        while (current++ < last) result.push(ip.fromLong(current))\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Sends a ping to all servers to update the arp table.\n */\nfunction pingServers () {\n  return Promise.all(servers.map(pingServer))\n}\n\n/**\n * Pings and individual server to update the arp table.\n */\nfunction pingServer (address) {\n  return new Promise(function (resolve) {\n    var socket = new net.Socket()\n    socket.setTimeout(1000, close)\n    socket.connect(80, address, close)\n    socket.once('error', close)\n\n    function close () {\n      socket.destroy()\n      resolve(address)\n    }\n  })\n}\n\n/**\n * Reads the arp table.\n */\nfunction arpAll () {\n  return cp.exec('arp -a', options).then(parseAll)\n}\n\n/**\n * Parses arp scan data into a useable collection.\n */\nfunction parseAll (data) {\n  if (!data || !data[0]) {\n    return []\n  }\n\n  if (process.platform.includes('linux')) {\n    var rows = data[0].split('\\n')\n    return rows.map(function (row) {\n      return parseLinux(row, servers)\n    }).filter(Boolean)\n  } else if (process.platform.includes('win32')) {\n    var winRows = data[0].split('\\n').splice(1)\n    return winRows.map(function (row) {\n      return parseWin32(row, servers)\n    }).filter(Boolean)\n  }\n\n  return data[0]\n    .trim()\n    .split('\\n')\n    .map(function (row) {\n      return parseRow(row, servers)\n    })\n    .filter(Boolean)\n}\n\n/**\n * Reads the arp table for a single address.\n */\nfunction arpOne (address) {\n  if (!ip.isV4Format(address) && !ip.isV6Format(address)) {\n    return Promise.reject(new Error('Invalid IP address provided.'))\n  }\n\n  return cp.exec('arp -n ' + address, options).then(parseOne)\n}\n\n/**\n * Parses a single row of arp data.\n */\nfunction parseOne (data) {\n  if (!data || !data[0]) {\n    return\n  }\n\n  if (process.platform.includes('linux')) {\n    // ignore unresolved hosts (can happen when parseOne returns only one unresolved host)\n    if (data[0].indexOf('no entry') >= 0) {\n      return\n    }\n\n    // remove first row (containing \"headlines\")\n    var rows = data[0].split('\\n').slice(1)[0]\n    return parseLinux(rows, servers, true)\n  } else if (process.platform.includes('win32')) {\n    return // currently not supported\n  }\n\n  return parseRow(data[0], servers)\n}\n\n/**\n * Clears the current promise and unlocks (will ping servers again).\n */\nfunction unlock (key) {\n  return function (data) {\n    lock[key] = null\n    return data\n  }\n}\n"]},"metadata":{},"sourceType":"script"}