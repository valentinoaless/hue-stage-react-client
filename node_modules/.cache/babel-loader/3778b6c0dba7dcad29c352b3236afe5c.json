{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/Users/barco/Desktop/sites/tests/dnd-tests/test6/client/src/set-controls.jsx\",\n    _s = $RefreshSig$();\n\nimport React, { useState } from 'react';\nimport styled from 'styled-components';\nimport { set } from './data';\nimport { bridge } from './bridge'; // play button\n// pause button\n// tempo\n// i.e. tempo = 140, beat happens at second measure (4 beats)\n// 1 measure has x beats\n// measure length in ms = /\n// tempo == beats in 60s\n\nlet tempo = 120;\nlet beatsPerMeasure = 4;\nlet beatValue = 4; // 1/4 (quarter)\n// get current time and every 50 ms check what objects have a play time before current time\n// after copying state and sending, delete those objects from the play time\n// render all states \n// when rendering states, make an array with objects\n// each object will have two properties, playTime and an array of all the states\n//disable all controls and dnd interface\n\n/*\n\n\n*/\n\nconst SetControls = () => {\n  _s();\n\n  let [playing, setPlaying] = useState(false);\n\n  const play = () => {\n    if (!playing) {\n      let playerQueues = [];\n      set.map(light => {\n        let millisecondOcurrence = 0;\n        light.gridStates.map(state => {\n          let millisecondDuration = 60000 / tempo * beatsPerMeasure * state.duration;\n          playerQueues.push({\n            occurrenceTime: millisecondOcurrence,\n            properties: {\n              state: state,\n              bridgeIndex: light.bridgeIndex\n            }\n          });\n          millisecondOcurrence += millisecondDuration;\n        });\n      });\n      let startTime = new Date();\n      let player = setInterval(() => {\n        let currentTime = new Date();\n        let elapsedTime = currentTime - startTime;\n        let queueCopy = [...playerQueues];\n        let messages = queueCopy.filter(state => {\n          return state.occurrenceTime <= elapsedTime;\n        });\n        playerQueues = queueCopy.filter(state => state.occurrenceTime > elapsedTime);\n        messages.map(message => {\n          bridge.send(message.properties.bridgeIndex, message.properties.state.data());\n          console.log(message.properties.state, message.properties.bridgeIndex);\n        });\n\n        if (playerQueues.length === 0) {\n          clearInterval(player);\n          setPlaying(false);\n        }\n      }, 50);\n    }\n\n    setPlaying(!playing);\n  };\n\n  return /*#__PURE__*/_jsxDEV(Controls, {\n    children: [/*#__PURE__*/_jsxDEV(Play, {\n      playing: playing,\n      onClick: play\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 114,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Stop, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 115,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 113,\n    columnNumber: 9\n  }, this);\n};\n\n_s(SetControls, \"TknKTnbLvtkeUADVhXhEVXKXunU=\");\n\n_c = SetControls;\nexport default SetControls;\nconst Controls = styled.div`\n    color: white; \n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\n_c2 = Controls;\nconst Play = styled.div`\n    width: 20px;\n    height: 20px;\n    margin: 20px;\n    transform: rotate(45deg);\n    cursor: pointer;\n    background-color: ${props => props.playing ? 'green' : 'white'};\n    :hover {\n        background-color: darkgreen;\n    }\n`;\n_c3 = Play;\nconst Stop = styled.div`\n    width: 20px;\n    height: 20px;\n    margin: 20px;\n    cursor: pointer;\n    background-color: white;\n    :hover {\n        background-color: darkred;\n    }\n    :active {\n        background-color: red;\n    }\n`;\n_c4 = Stop;\n\nvar _c, _c2, _c3, _c4;\n\n$RefreshReg$(_c, \"SetControls\");\n$RefreshReg$(_c2, \"Controls\");\n$RefreshReg$(_c3, \"Play\");\n$RefreshReg$(_c4, \"Stop\");","map":{"version":3,"sources":["/Users/barco/Desktop/sites/tests/dnd-tests/test6/client/src/set-controls.jsx"],"names":["React","useState","styled","set","bridge","tempo","beatsPerMeasure","beatValue","SetControls","playing","setPlaying","play","playerQueues","map","light","millisecondOcurrence","gridStates","state","millisecondDuration","duration","push","occurrenceTime","properties","bridgeIndex","startTime","Date","player","setInterval","currentTime","elapsedTime","queueCopy","messages","filter","message","send","data","console","log","length","clearInterval","Controls","div","Play","props","Stop"],"mappings":"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","sourcesContent":["import React, {useState} from 'react';\nimport styled from 'styled-components';\nimport { set } from './data'\nimport { bridge } from './bridge'\n\n// play button\n// pause button\n// tempo\n\n// i.e. tempo = 140, beat happens at second measure (4 beats)\n\n// 1 measure has x beats\n// measure length in ms = /\n\n// tempo == beats in 60s\nlet tempo = 120;\nlet beatsPerMeasure = 4;\nlet beatValue = 4; // 1/4 (quarter)\n\n// get current time and every 50 ms check what objects have a play time before current time\n\n// after copying state and sending, delete those objects from the play time\n\n\n// render all states \n// when rendering states, make an array with objects\n// each object will have two properties, playTime and an array of all the states\n\n\n\n//disable all controls and dnd interface\n\n/*\n\n\n*/\n\n\nconst SetControls = () => {\n\n    let [playing, setPlaying] = useState(false);\n\n    const play = () => {\n\n\n        if(!playing) {\n\n            \n        \n            let playerQueues = [];\n        \n            set.map(light => {\n\n                let millisecondOcurrence = 0;\n\n                light.gridStates.map(state => {\n\n                    let millisecondDuration = ((60000/tempo) * beatsPerMeasure) * state.duration\n                    \n                    playerQueues.push({\n                        occurrenceTime: millisecondOcurrence,\n                        properties: {\n                            state: state,\n                            bridgeIndex: light.bridgeIndex\n                        }\n                    })\n                    \n                    millisecondOcurrence += millisecondDuration;\n\n                })\n\n            })\n\n            let startTime = new Date()\n\n            let player = setInterval(()=>{\n\n                let currentTime = new Date()\n                let elapsedTime = currentTime - startTime;\n                let queueCopy = [...playerQueues]\n\n                let messages = queueCopy.filter(state => {\n                    return state.occurrenceTime <= elapsedTime\n                });\n\n                playerQueues = queueCopy.filter(state => state.occurrenceTime > elapsedTime );\n\n                messages.map(message => {\n                    bridge.send(message.properties.bridgeIndex, message.properties.state.data())\n                    console.log(message.properties.state, message.properties.bridgeIndex)\n                })\n\n                if(playerQueues.length === 0) {\n                    clearInterval(player);\n                    setPlaying(false);\n                }\n\n            }, 50)\n\n\n    \n        } \n\n        setPlaying(!playing);\n\n        \n\n    \n    }\n\n\n    return (\n        <Controls >\n            <Play playing={playing} onClick={play}/>\n            <Stop />\n        </Controls>\n    );\n};\n\nexport default SetControls;\n\nconst Controls = styled.div`\n    color: white; \n    display: flex;\n    justify-content: center;\n    align-items: center;\n`\n\nconst Play = styled.div`\n    width: 20px;\n    height: 20px;\n    margin: 20px;\n    transform: rotate(45deg);\n    cursor: pointer;\n    background-color: ${props => props.playing ? 'green' : 'white' };\n    :hover {\n        background-color: darkgreen;\n    }\n`\n\nconst Stop = styled.div`\n    width: 20px;\n    height: 20px;\n    margin: 20px;\n    cursor: pointer;\n    background-color: white;\n    :hover {\n        background-color: darkred;\n    }\n    :active {\n        background-color: red;\n    }\n`"]},"metadata":{},"sourceType":"module"}