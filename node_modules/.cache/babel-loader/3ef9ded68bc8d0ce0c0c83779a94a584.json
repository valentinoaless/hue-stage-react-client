{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/Users/barco/Desktop/sites/tests/dnd-tests/test6/client/src/set-controls.jsx\",\n    _s = $RefreshSig$();\n\nimport React, { useState } from 'react';\nimport styled from 'styled-components';\nimport { set } from './data';\nimport { bridge } from './bridge'; // play button\n// pause button\n// tempo\n// i.e. tempo = 140, beat happens at second measure (4 beats)\n// 1 measure has x beats\n// measure length in ms = /\n// tempo == beats in 60s\n\nlet tempo = 120;\nlet beatsPerMeasure = 4;\nlet beatValue = 4; // 1/4 (quarter)\n// get current time and every 50 ms check what objects have a play time before current time\n// after copying state and sending, delete those objects from the play time\n// render all states \n// when rendering states, make an array with objects\n// each object will have two properties, playTime and an array of all the states\n//disable all controls and dnd interface\n\n/*\n\n\n*/\n\nconst SetControls = () => {\n  _s();\n\n  let stopButtonPressed = {\n    state: false\n  };\n  let [stopped, setStopped] = useState(false);\n  let [playing, setPlaying] = useState(false);\n  console.log(stopped);\n\n  const play = () => {\n    if (!playing) {\n      setPlaying(true);\n      let playerQueues = [];\n      set.map(light => {\n        let millisecondOcurrence = 0;\n        light.gridStates.map(state => {\n          let millisecondDuration = 60000 / tempo * beatsPerMeasure * state.duration;\n          playerQueues.push({\n            occurrenceTime: millisecondOcurrence,\n            properties: {\n              state: state,\n              bridgeIndex: light.bridgeIndex\n            }\n          });\n          millisecondOcurrence += millisecondDuration;\n        });\n      });\n      let startTime = new Date();\n      let player = setInterval(() => {\n        let currentTime = new Date();\n        let elapsedTime = currentTime - startTime;\n        let queueCopy = [...playerQueues];\n        let messages = queueCopy.filter(state => {\n          return state.occurrenceTime <= elapsedTime;\n        });\n        messages.map(message => {\n          bridge.send(message.properties.bridgeIndex, message.properties.state.data()); //console.log(message.properties.state, message.properties.bridgeIndex)\n        });\n        playerQueues = queueCopy.filter(state => state.occurrenceTime > elapsedTime);\n        console.log(stopButtonPressed.state);\n\n        if (playerQueues.length === 0 || stopButtonPressed.state) {\n          stopButtonPressed.state = false;\n          setPlaying(false);\n          setStopped(false);\n          clearInterval(player);\n        }\n      }, 50);\n    }\n  };\n\n  const stop = () => {\n    if (!stopped) {\n      stopButtonPressed.state = true;\n      setStopped(true);\n      console.log(stopped);\n      setPlaying(false);\n    }\n  };\n\n  return /*#__PURE__*/_jsxDEV(Controls, {\n    children: [/*#__PURE__*/_jsxDEV(Play, {\n      playing: playing,\n      onClick: play\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 126,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Stop, {\n      onClick: stop\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 125,\n    columnNumber: 9\n  }, this);\n};\n\n_s(SetControls, \"gc5Z19Mao9d3O6erZYISx9YuC9U=\");\n\n_c = SetControls;\nexport default SetControls;\nconst Controls = styled.div`\n    color: white; \n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\n_c2 = Controls;\nconst Play = styled.div`\n    width: 20px;\n    height: 20px;\n    margin: 20px;\n    transform: rotate(45deg);\n    cursor: pointer;\n    background-color: ${props => props.playing ? 'green' : 'white'};\n    :hover {\n        background-color: darkgreen;\n    }\n`;\n_c3 = Play;\nconst Stop = styled.div`\n    width: 20px;\n    height: 20px;\n    margin: 20px;\n    cursor: pointer;\n    background-color: white;\n    :hover {\n        background-color: red;\n    }\n    :active {\n        background-color: darkred;\n    }\n`;\n_c4 = Stop;\n\nvar _c, _c2, _c3, _c4;\n\n$RefreshReg$(_c, \"SetControls\");\n$RefreshReg$(_c2, \"Controls\");\n$RefreshReg$(_c3, \"Play\");\n$RefreshReg$(_c4, \"Stop\");","map":{"version":3,"sources":["/Users/barco/Desktop/sites/tests/dnd-tests/test6/client/src/set-controls.jsx"],"names":["React","useState","styled","set","bridge","tempo","beatsPerMeasure","beatValue","SetControls","stopButtonPressed","state","stopped","setStopped","playing","setPlaying","console","log","play","playerQueues","map","light","millisecondOcurrence","gridStates","millisecondDuration","duration","push","occurrenceTime","properties","bridgeIndex","startTime","Date","player","setInterval","currentTime","elapsedTime","queueCopy","messages","filter","message","send","data","length","clearInterval","stop","Controls","div","Play","props","Stop"],"mappings":";;;;;AAAA,OAAOA,KAAP,IAAeC,QAAf,QAA8B,OAA9B;AACA,OAAOC,MAAP,MAAmB,mBAAnB;AACA,SAASC,GAAT,QAAoB,QAApB;AACA,SAASC,MAAT,QAAuB,UAAvB,C,CAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;;AACA,IAAIC,KAAK,GAAG,GAAZ;AACA,IAAIC,eAAe,GAAG,CAAtB;AACA,IAAIC,SAAS,GAAG,CAAhB,C,CAAmB;AAEnB;AAEA;AAGA;AACA;AACA;AAIA;;AAEA;AACA;AACA;AACA;;AAEA,MAAMC,WAAW,GAAG,MAAM;AAAA;;AAGtB,MAAIC,iBAAiB,GAAG;AAACC,IAAAA,KAAK,EAAE;AAAR,GAAxB;AACA,MAAI,CAACC,OAAD,EAAUC,UAAV,IAAwBX,QAAQ,CAAC,KAAD,CAApC;AACA,MAAI,CAACY,OAAD,EAAUC,UAAV,IAAwBb,QAAQ,CAAC,KAAD,CAApC;AACAc,EAAAA,OAAO,CAACC,GAAR,CAAYL,OAAZ;;AAEA,QAAMM,IAAI,GAAG,MAAM;AAEf,QAAG,CAACJ,OAAJ,EAAa;AAETC,MAAAA,UAAU,CAAC,IAAD,CAAV;AAEA,UAAII,YAAY,GAAG,EAAnB;AAEAf,MAAAA,GAAG,CAACgB,GAAJ,CAAQC,KAAK,IAAI;AAEb,YAAIC,oBAAoB,GAAG,CAA3B;AAEAD,QAAAA,KAAK,CAACE,UAAN,CAAiBH,GAAjB,CAAqBT,KAAK,IAAI;AAE1B,cAAIa,mBAAmB,GAAK,QAAMlB,KAAP,GAAgBC,eAAjB,GAAoCI,KAAK,CAACc,QAApE;AAEAN,UAAAA,YAAY,CAACO,IAAb,CAAkB;AACdC,YAAAA,cAAc,EAAEL,oBADF;AAEdM,YAAAA,UAAU,EAAE;AACRjB,cAAAA,KAAK,EAAEA,KADC;AAERkB,cAAAA,WAAW,EAAER,KAAK,CAACQ;AAFX;AAFE,WAAlB;AAQAP,UAAAA,oBAAoB,IAAIE,mBAAxB;AAEH,SAdD;AAgBH,OApBD;AAsBA,UAAIM,SAAS,GAAG,IAAIC,IAAJ,EAAhB;AAEA,UAAIC,MAAM,GAAGC,WAAW,CAAC,MAAI;AAEzB,YAAIC,WAAW,GAAG,IAAIH,IAAJ,EAAlB;AACA,YAAII,WAAW,GAAGD,WAAW,GAAGJ,SAAhC;AACA,YAAIM,SAAS,GAAG,CAAC,GAAGjB,YAAJ,CAAhB;AAEA,YAAIkB,QAAQ,GAAGD,SAAS,CAACE,MAAV,CAAiB3B,KAAK,IAAI;AACrC,iBAAOA,KAAK,CAACgB,cAAN,IAAwBQ,WAA/B;AACH,SAFc,CAAf;AAIAE,QAAAA,QAAQ,CAACjB,GAAT,CAAamB,OAAO,IAAI;AACpBlC,UAAAA,MAAM,CAACmC,IAAP,CAAYD,OAAO,CAACX,UAAR,CAAmBC,WAA/B,EAA4CU,OAAO,CAACX,UAAR,CAAmBjB,KAAnB,CAAyB8B,IAAzB,EAA5C,EADoB,CAEpB;AACH,SAHD;AAKAtB,QAAAA,YAAY,GAAGiB,SAAS,CAACE,MAAV,CAAiB3B,KAAK,IAAIA,KAAK,CAACgB,cAAN,GAAuBQ,WAAjD,CAAf;AAGAnB,QAAAA,OAAO,CAACC,GAAR,CAAYP,iBAAiB,CAACC,KAA9B;;AAEA,YAAGQ,YAAY,CAACuB,MAAb,KAAwB,CAAxB,IAA6BhC,iBAAiB,CAACC,KAAlD,EAAyD;AACrDD,UAAAA,iBAAiB,CAACC,KAAlB,GAA0B,KAA1B;AACAI,UAAAA,UAAU,CAAC,KAAD,CAAV;AACAF,UAAAA,UAAU,CAAC,KAAD,CAAV;AACA8B,UAAAA,aAAa,CAACX,MAAD,CAAb;AACH;AAEJ,OA3BuB,EA2BrB,EA3BqB,CAAxB;AA6BH;AAEJ,GA/DD;;AAiEA,QAAMY,IAAI,GAAG,MAAM;AAEf,QAAG,CAAChC,OAAJ,EAAa;AAETF,MAAAA,iBAAiB,CAACC,KAAlB,GAA0B,IAA1B;AACAE,MAAAA,UAAU,CAAC,IAAD,CAAV;AACAG,MAAAA,OAAO,CAACC,GAAR,CAAYL,OAAZ;AACAG,MAAAA,UAAU,CAAC,KAAD,CAAV;AACH;AAEJ,GAVD;;AAaA,sBACI,QAAC,QAAD;AAAA,4BACI,QAAC,IAAD;AAAM,MAAA,OAAO,EAAED,OAAf;AAAwB,MAAA,OAAO,EAAEI;AAAjC;AAAA;AAAA;AAAA;AAAA,YADJ,eAEI,QAAC,IAAD;AAAM,MAAA,OAAO,EAAE0B;AAAf;AAAA;AAAA;AAAA;AAAA,YAFJ;AAAA;AAAA;AAAA;AAAA;AAAA,UADJ;AAMH,CA5FD;;GAAMnC,W;;KAAAA,W;AA8FN,eAAeA,WAAf;AAEA,MAAMoC,QAAQ,GAAG1C,MAAM,CAAC2C,GAAI;AAC5B;AACA;AACA;AACA;AACA,CALA;MAAMD,Q;AAON,MAAME,IAAI,GAAG5C,MAAM,CAAC2C,GAAI;AACxB;AACA;AACA;AACA;AACA;AACA,wBAAwBE,KAAK,IAAIA,KAAK,CAAClC,OAAN,GAAgB,OAAhB,GAA0B,OAAS;AACpE;AACA;AACA;AACA,CAVA;MAAMiC,I;AAYN,MAAME,IAAI,GAAG9C,MAAM,CAAC2C,GAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAZA;MAAMG,I","sourcesContent":["import React, {useState} from 'react';\nimport styled from 'styled-components';\nimport { set } from './data'\nimport { bridge } from './bridge'\n\n// play button\n// pause button\n// tempo\n\n// i.e. tempo = 140, beat happens at second measure (4 beats)\n\n// 1 measure has x beats\n// measure length in ms = /\n\n// tempo == beats in 60s\nlet tempo = 120;\nlet beatsPerMeasure = 4;\nlet beatValue = 4; // 1/4 (quarter)\n\n// get current time and every 50 ms check what objects have a play time before current time\n\n// after copying state and sending, delete those objects from the play time\n\n\n// render all states \n// when rendering states, make an array with objects\n// each object will have two properties, playTime and an array of all the states\n\n\n\n//disable all controls and dnd interface\n\n/*\n\n\n*/\n\nconst SetControls = () => {\n    \n\n    let stopButtonPressed = {state: false};\n    let [stopped, setStopped] = useState(false);\n    let [playing, setPlaying] = useState(false);\n    console.log(stopped);\n    \n    const play = () => {\n\n        if(!playing) {\n\n            setPlaying(true);\n\n            let playerQueues = [];\n        \n            set.map(light => {\n\n                let millisecondOcurrence = 0;\n\n                light.gridStates.map(state => {\n\n                    let millisecondDuration = ((60000/tempo) * beatsPerMeasure) * state.duration\n                    \n                    playerQueues.push({\n                        occurrenceTime: millisecondOcurrence,\n                        properties: {\n                            state: state,\n                            bridgeIndex: light.bridgeIndex\n                        }\n                    })\n                    \n                    millisecondOcurrence += millisecondDuration;\n\n                })\n\n            })\n\n            let startTime = new Date()\n\n            let player = setInterval(()=>{\n\n                let currentTime = new Date()\n                let elapsedTime = currentTime - startTime;\n                let queueCopy = [...playerQueues]\n\n                let messages = queueCopy.filter(state => {\n                    return state.occurrenceTime <= elapsedTime\n                });\n\n                messages.map(message => {\n                    bridge.send(message.properties.bridgeIndex, message.properties.state.data())\n                    //console.log(message.properties.state, message.properties.bridgeIndex)\n                })\n                \n                playerQueues = queueCopy.filter(state => state.occurrenceTime > elapsedTime );\n\n\n                console.log(stopButtonPressed.state)\n\n                if(playerQueues.length === 0 || stopButtonPressed.state) {\n                    stopButtonPressed.state = false;\n                    setPlaying(false);\n                    setStopped(false);\n                    clearInterval(player);\n                }\n\n            }, 50)\n\n        } \n\n    }\n\n    const stop = () => {\n\n        if(!stopped) {\n\n            stopButtonPressed.state = true;\n            setStopped(true);\n            console.log(stopped)\n            setPlaying(false);\n        }\n\n    }\n\n\n    return (\n        <Controls >\n            <Play playing={playing} onClick={play}/>\n            <Stop onClick={stop}/>\n        </Controls>\n    );\n};\n\nexport default SetControls;\n\nconst Controls = styled.div`\n    color: white; \n    display: flex;\n    justify-content: center;\n    align-items: center;\n`\n\nconst Play = styled.div`\n    width: 20px;\n    height: 20px;\n    margin: 20px;\n    transform: rotate(45deg);\n    cursor: pointer;\n    background-color: ${props => props.playing ? 'green' : 'white' };\n    :hover {\n        background-color: darkgreen;\n    }\n`\n\nconst Stop = styled.div`\n    width: 20px;\n    height: 20px;\n    margin: 20px;\n    cursor: pointer;\n    background-color: white;\n    :hover {\n        background-color: red;\n    }\n    :active {\n        background-color: darkred;\n    }\n`"]},"metadata":{},"sourceType":"module"}