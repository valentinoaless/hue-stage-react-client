{"ast":null,"code":"import axios from 'axios';\nimport { set } from './data';\nimport Light from './state-model';\nlet bridgeUser = \"8SdmTqNxhLaIgHo28qv5JCeAjbsby0Hl7W9-jmKI\";\nlet bridgeIp = '';\n\nconst getBridgeIP = () => {\n  return axios.get('https://discovery.meethue.com').then(res => {\n    bridgeIp = res.data[0].internalipaddress;\n    return res.data[0].internalipaddress;\n  });\n};\n\nconst connectToBridge = (ip, user) => {\n  if (user) {\n    axios.get(`http://${ip}/api/${user}`).then(res => {});\n  } else {\n    createUser(ip).then(res => {\n      axios.get(`http://${ip}/api/${res}`).then(res => {\n        console.log(res);\n      });\n    });\n  }\n};\n\nconst createUser = ip => {\n  let request = new Promise((resolve, reject) => {\n    let requestsMade = 0;\n    let bridgeRequest = setInterval(() => {\n      axios.post(`http://${ip}/api`, {\n        devicetype: \"hue-stage-wep-app\"\n      }).then(res => {\n        if (!res.data[0].error) {\n          resolve(res.data[0].success.username);\n          requestsMade += 1;\n          clearInterval(bridgeRequest);\n        } else {\n          console.log(res.data[0].error);\n        }\n      }).catch(err => {\n        console.log(err);\n      });\n\n      if (requestsMade > 15) {\n        reject('Unable to create user');\n        clearInterval(bridgeRequest);\n      }\n    }, 2000);\n  });\n  return request;\n};\n\nexport const bridge = {\n  connect: async () => {\n    await getBridgeIP().then(ip => {\n      connectToBridge(ip, bridgeUser);\n    });\n  },\n\n  test(light, state) {\n    axios.put(`http://${bridgeIp}/api/${bridgeUser}/lights/${light}/state`, state.data()).then(res => {\n      console.log(res);\n    });\n  },\n\n  send() {},\n\n  getLights: async () => {\n    let reachableLights = [];\n    await axios.get(`http://${bridgeIp}/api/${bridgeUser}/lights/`).then(res => {\n      let lights = Object.entries(res.data);\n      lights.map(light => {\n        if (light[1].state.reachable) {\n          reachableLights.push(light);\n        }\n      });\n    });\n    return reachableLights;\n  },\n\n  loadLights() {\n    let reachableLights = [];\n    return this.getLights().then(res => {\n      reachableLights = res;\n      reachableLights.map(light => {\n        set.push(new Light(light[0], light[1].name, light[1].uniqueid, []));\n        return null;\n      });\n      return true;\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/barco/Desktop/sites/tests/dnd-tests/test6/client/src/bridge.js"],"names":["axios","set","Light","bridgeUser","bridgeIp","getBridgeIP","get","then","res","data","internalipaddress","connectToBridge","ip","user","createUser","console","log","request","Promise","resolve","reject","requestsMade","bridgeRequest","setInterval","post","devicetype","error","success","username","clearInterval","catch","err","bridge","connect","test","light","state","put","send","getLights","reachableLights","lights","Object","entries","map","reachable","push","loadLights","name","uniqueid"],"mappings":"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","sourcesContent":["import axios from 'axios';\nimport { set } from './data';\nimport Light from './state-model';\n\nlet bridgeUser = \"8SdmTqNxhLaIgHo28qv5JCeAjbsby0Hl7W9-jmKI\";\nlet bridgeIp = '';\n\nconst getBridgeIP = () => {\n    return axios.get('https://discovery.meethue.com').then(res => {\n        bridgeIp = res.data[0].internalipaddress\n        return res.data[0].internalipaddress\n    })\n}\n\nconst connectToBridge = (ip, user) => {\n  if(user) {\n      axios.get(`http://${ip}/api/${user}`).then(res => {\n      })\n  } else {\n      createUser(ip).then(res => {\n        axios.get(`http://${ip}/api/${res}`).then(res => {\n          console.log(res);\n        })\n      });\n  }\n}\n\nconst createUser = (ip) => {\n\n  let request = new Promise((resolve, reject) => {\n\n    let requestsMade = 0;\n    \n    let bridgeRequest = setInterval(()=>{\n      axios.post(`http://${ip}/api`, {devicetype: \"hue-stage-wep-app\"})\n        .then(res => {\n          if (!res.data[0].error) {\n            resolve(res.data[0].success.username);\n            requestsMade += 1;\n            clearInterval(bridgeRequest);\n          } else {\n            console.log(res.data[0].error)\n          }\n      }).catch(err => {\n        console.log(err);\n      })\n  \n      if(requestsMade > 15) {\n        reject('Unable to create user')\n        clearInterval(bridgeRequest);\n      }\n      \n    }, 2000);\n\n  })\n\n  return request;\n\n}\n\nexport const bridge = {\n    connect: async () => {\n        await getBridgeIP().then(ip => {\n            connectToBridge(ip, bridgeUser)\n        })\n    },\n\n    test(light, state) {\n        axios.put(`http://${bridgeIp}/api/${bridgeUser}/lights/${light}/state`, state.data())\n        .then(res => {\n            console.log(res);\n        })\n    },\n\n    send() {\n\n    },\n\n    getLights: async () => {\n\n        let reachableLights = [];\n\n        await axios.get(`http://${bridgeIp}/api/${bridgeUser}/lights/`).then(res => {\n\n            let lights = Object.entries(res.data);\n            lights.map(light => {\n                if(light[1].state.reachable) {\n                    reachableLights.push(light);\n                }\n            })\n        })\n        \n        \n        return reachableLights;\n    },\n\n    loadLights() {\n\n        let reachableLights = [] \n        return this.getLights().then(res => {\n            reachableLights = res;\n            reachableLights.map(light => {\n                set.push(new Light(light[0], light[1].name, light[1].uniqueid, []))\n                return null;\n            })\n            return true;\n        })\n\n        \n    }\n\n\n}\n"]},"metadata":{},"sourceType":"module"}